## 渲染组件

```js
function patch(n1, n2, container, anchor){
  if(n1 && n1.type !== n2.type){
    unmount(n1)
    n1 = null
  }
  
  const { type } = n2
  if(typeof type === 'string'){
    // 普通元素
  }else if(type === Text){
    // 文本节点
  }else if(type === Fragment){
    // 片段
  }else if (typeof type === 'object'){
    // 组件
    if(!n1){
      // 挂载
      mountComponent(n2, container, anchor)
    }else{
      // 更新
      patchComponent(n1, n2, anchor)
    }
  }
}
```

渲染组件必须包含 `render` 函数

```js
const myComponent = {
  name: 'myComponent',
  // 返回值为虚拟 dom
  render(){
    return {
      type: 'div',
      children: 'hello world'
    }
  }
}
```

## 组件状态与自更新

```js
const myComponent = {
  name: 'myComponent',
  data(){
    return {
      age: 18
    }
  },
  render(){
    return {
      type: 'div',
      children: `今年${this.age}岁`
    }
  }
}
```

```js
function mountComponent(vnode, container, anchor){
  const componentOptions = vnode.type
  
  const { render, data } = componentOptions
  // 调用 data 获取原始数据，并调用 reactive 包装为响应式数据
  const state = reactive(data())


  effect(()=>{
    // 调用 render 函数时，this 指向 state， 从而使 render 函数中的 this 可以访问自身的数据
    const subTree = render.call(state, state)

    patch(null, subTree, container, anchor)
  }, {
    // 指定副作用的函数调度器
    scheduler: queueJob
  })  
}

```

1. 通过 `reactive` 函数将 `data` 函数返回状态包装为响应式数据
2. 调用 `render` 函数时，把 `this` 指向响应式数据 `state`, 同时把 `state` 作为参数传入 `render` 函数
3. 将渲染任务包装到 `effect` 中，从而触发自动更新
4. 异步更新；由于 `effect` 是同步的，因此需要设置一个调度器，通过微任务队列 `queueJob` 来实现异步更新，并且对缓存的任务进行去重。

## 组件实例与生命周期

组件实例是一个状态的集合，维护组件运行的所有信息：生命周期，渲染树，自身状态

```js
function mountComponent(vnode, container, anchor){
  const componentOptions = vnode.type
  // 从组件的选项中获取生命周期钩子函数
  const { render, data, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeUnmount, unmounted } = componentOptions
  
  // 调用 beforeCreate 钩子函数
  beforeCreate && beforeCreate.call(null)
  
  const state = reactive(data())
  const instance = {
    // 组件自身的状态
    state,
    // 是否被挂载
    isMounted: false,
    // 渲染内容
    subTree: null,
  }
  
  // 调用 created 钩子函数
  created && created.call(state)
  
  effect(()=>{
    const subTree = render.call(state, state)
    if(!instance.isMounted){
      // 调用 beforeMount 钩子函数
      beforeMount && beforeMount.call(state)
      patch(null, subTree, container, anchor)
      
      instance.isMounted = true
      // 调用 mounted 钩子函数
      mounted && mounted.call(state)
    }else{
      // 调用 beforeUpdate 钩子函数
      beforeUpdate && beforeUpdate.call(state)
      patch(instance.subTree, subTree, container, anchor)
      // 调用 updated 钩子函数
      updated && updated.call(state)
    }
    
    instance.subTree = subTree
  }, {
    scheduler: queueJob
  })
}
```

## props 与组件的被动更新

